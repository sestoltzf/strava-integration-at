var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
function predicateToSQL(predicate, resolveName) {
    var _a;
    var column = predicate.column, compare = predicate.compare;
    // If we cannot find the column name, we just use the column name as is.
    // It's possible that the column exists but we just don't know it on the client.
    var columnName = (_a = resolveName(column)) !== null && _a !== void 0 ? _a : String(column);
    if ("other" in predicate) {
        var other = predicate.other;
        // TODO this is a bit too tricky. If the RHS matches a column name, we treat it as such. Otherwise we use it bare.
        var otherColumn = resolveName(other);
        if (otherColumn !== undefined) {
            return "\"".concat(columnName, "\" ").concat(compare, " \"").concat(otherColumn, "\"");
        }
        else {
            // We did not resolve the RHS to a column name, so we treat it as a value.
            // It's possible that this is actually a column that exists in the table,
            // but the client does not know about it.
            // This quoting is bad â€“ we should require client users to do this.
            var bareValue = typeof other === "string" ? "'".concat(other, "'") : other;
            return "\"".concat(columnName, "\" ").concat(compare, " ").concat(String(bareValue));
        }
    }
    return "\"".concat(columnName, "\" ").concat(compare);
}
var QueryBuilder = /** @class */ (function () {
    function QueryBuilder(props) {
        this.props = props;
        this._and = [];
        this._or = [];
    }
    QueryBuilder.prototype.toSQL = function () {
        var _a;
        var _b = this.props, table = _b.table, displayNameToName = _b.displayNameToName;
        var sql = "SELECT * FROM \"".concat(table, "\"");
        var predicates = this._where === undefined ? [] : __spreadArray(__spreadArray([this._where], this._and, true), this._or, true);
        if (predicates.length > 0) {
            sql += " WHERE ";
            var AND_OR = this._and.length > 0 ? " AND " : " OR ";
            sql += predicates.map(function (p) { return predicateToSQL(p, displayNameToName); }).join(AND_OR);
        }
        if (this._orderBy !== undefined) {
            var _c = this._orderBy, column = _c.column, _d = _c.order, order = _d === void 0 ? "ASC" : _d;
            // If we cannot find the column name, we just use the column name as is.
            // It's possible that the column exists but we just don't know it on the client.
            var columnName = (_a = displayNameToName(column)) !== null && _a !== void 0 ? _a : String(column);
            sql += " ORDER BY \"".concat(columnName, "\" ").concat(order);
        }
        if (this._limit !== undefined) {
            sql += " LIMIT ".concat(this._limit);
        }
        return sql;
    };
    QueryBuilder.prototype.orderBy = function (column, order) {
        this._orderBy = { column: column, order: order };
        return this;
    };
    QueryBuilder.prototype.limit = function (n) {
        this._limit = n;
        return this;
    };
    QueryBuilder.prototype.where = function (column, compare, other) {
        this._where = { column: column, compare: compare, other: other };
        return this;
    };
    QueryBuilder.prototype.and = function (column, compare, other) {
        this._and.push({ column: column, compare: compare, other: other });
        return this;
    };
    QueryBuilder.prototype.or = function (column, compare, other) {
        this._or.push({ column: column, compare: compare, other: other });
        return this;
    };
    return QueryBuilder;
}());
export { QueryBuilder };
//# sourceMappingURL=QueryBuilder.js.map